<!DOCTYPE html>
<html>
    <body>
        <p>&nbsp;</p>         
		<h1>Homework 2</h1>
		<p>Due: 11:59pm, Monday, Sep 20, 2021</p>
		<p>100 points</p>
		
		<p>For all further Racket assignments in this course, set the DrRacket Language to <code>Advanced Student</code> (under <code>How to Design Programs</code>). Your assignment will be graded using the specified language level. If you use a different language level, your code may not work when it is graded.</p>
		
		<ul>
		<li>Carefully follow the Sample Solution to a Programming Problem in the <a href="https://htmlpreview.github.io/?https://github.com/JavaPLT/COMP311/blob/main/Fall2021/Racket%20HW%20Guide.html">Racket HW Guide</a>. Only half of the credit for each programming problem is based on the the correctness of your code as determined by our test cases. Much of the grade is based on how well you follow the design recipe.
		
		Beware of typos such as mistyping the name of a function (<em>e.g.</em>, <code>empty</code> instead of <code>empty?</code>) or improperly matched parentheses.</li><br>
		
		<li>Read or skim chapters 11-13 in the HTDP textbook, First Edition.  If you are not yet comfortable with writing structurally recursive definitions for functions, you should also read or skim chapters 9-10.</li></br>
		
		<li>Do the following programming problems:<br>
		<ol>
		<span style="color: rgb(0,0,0);"><br /></span><li>[<a data-content-title="30 pts" data-linked-resource-default-alias="30 pts" href="#">30 pts</a>] 
		Section 14.2 in the HTDP textbook (First Edition) describes what it calls Binary Search Trees.  This terminology is non-standard because according to the book Binary Search Trees contain both keys and values in each node and hence represent searchable finite mappings from keys to values.  \(In Java, essentially the same form of data is called a <code>TreeMap</code> while a conventional binary search tree is called a <code>TreeSet</code>.\)
		The stub file <code>HW02.rkt</code> describes a simple Racket programming problem (with a solution consisting of only a few lines of executable Racket code) based on essentially the same inductive data definition as Binary Search Trees in the book but the type of the <code>value</code> field is parametric (<code>alpha</code>) which must be instantiated to <code>symbol</code> to match the explication of Binary Search Trees in the book. Your task is to </span><ul><li><span style="color: rgb(0,0,0);">Give some examples of the <code>symbol-BSTM</code> type.</span></li><li><span style="color: rgb(0,0,0);">Devise a set of test cases (input output pairs expressed using <code>check-expect</code>) for the <code>getBSTM</code> function.</span><span style="color: rgb(0,0,0);"><br /></span></li><li><span style="color: rgb(0,0,0);">Write a Template Instantiation for <code>getBSTM</code> (based on the general template for functions that process <code>symbol-BSTM</code>s)</span></li><li><span style="color: rgb(0,0,0);">Develop the code for the function <code>getBSTM</code> that satisfies the contract given in the stub file.</span></li><li><span style="color: rgb(0,0,0);">Briefly compare the asymptotic worst case running time of searching a <code>symbol-BSTM</code> that is well balanced (maximum depth is proportional to the log N where N is the number of keys in the <code>symbol-BSTM</code>) and function searches an ordered list of <code>(key value)</code> pairs represented as two element lists (as in Problem 2 below).</span><span style="color: rgb(0,0,0);"><br /></span><span style="color: rgb(0,0,0);"><br /></span></li></ul><span style="color: rgb(0,0,0);">Each of these five subtasks, except for devising the collection of test cases, takes only a few lines.  A good set of test cases might take as many as 10 lines.</span><br />
		
		<span style="color: rgb(0,0,0);"><br /></span></li><li>[<a data-content-title="30 pts" data-linked-resource-default-alias="30 pts" href="#">30 pts</a>] The stub file HW02.rkt provides a detailed description of how to develop the function <code>cross</code> (and supporting function <code>cross-help</code>) that consumes a <code>number-list</code> and a <code>symbol-list</code> and produces a <code>number-symbol-pair-list </code>where a  <code>number-symbol-pair</code> is represented by a two element <code>list</code> containing a <code>number</code> and a <code>symbol</code>.<br /><br /></li><li><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">[30</span><a class="confluence-link unresolved" data-content-title="10 pts" data-linked-resource-default-alias="10 pts" href="#">&nbsp;pts</a><span style="color: rgb(0,0,0);">] The stub file HW02.rkt provides a detailed description of how to d</span>evelop the function <code>merge</code> (and supporting function <code>merge-help</code>) that consumes two ascending (<a class="confluence-link unresolved" data-content-title="technically non-descending" data-linked-resource-default-alias="technically non-descending" href="#">technically non-descending</a>} <code>number-list</code>s and merges them to form an ascending <code>number-list</code>.</span></span><br /><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"></li>
		
		<li><p>[<a class="confluence-link unresolved" data-content-title="10pts" data-linked-resource-default-alias="10pts" href="#">10pts</a>]The ubiquitous Fibonacci function defined by the trivial <code>fib</code> program given in the stub tile HW02.rkt is interminably slow (exponential running time) for large inputs.  Develop a Racket function <code>fastFib</code> that consumes a natural number input <code>n</code>, produces the same answer as the <code>fib</code> function defined in the stub file, and runs in linear time (assuming that the primitive addition operation runs in constant time, which fails for very large <code>n</code>).  Hint: write a help function <code>fastFibHelp</code> that accumulates the result in an accumulator argument performing essentially the same computation as an imperative program relying on a loop that maintains <code>fib(k-1)</code> and <code>fib(k-2)</code> in mutable variables as <code>k</code> increases from <code>2</code> to n.  The poor efficiency the trivial functional program for <code>fib</code> is due to the fact that it repeatedly computes the Fibonacci function for small <code><span style="font-family: monospace;">k</span></code> exponentially many times.</p><ul><li>Show Types, Contractz, Examples, and Template Instantiations for <code>fastFibHelp</code> and <code>fastFib</code>.  (The answers for the Template Instantiations can vary; only the salient features (primarily recursive calls) matter.)</li><li>As usual testing comes for free given that you provided input-output examples.  Make sure that after you run your program that no source code text (definitions of <code>fastFib</code> and <code>fastFibHelp)</code>is shaded in the DrRacket definitions panel.  Such shading indicates a failure to evaluate the shaded expressions in any test cases.<br /><br /></li></ul></li>
		
		<li><p><strong>Optional problem for extra credit: [50 pts]</strong><br />The Fibonacci function <em><code>fib</code></em> is defined in the stub for Problem 4 in HW02.rkt. The naive program for computing <code><em>fib</em></code> coded in the file HW02.rkt runs in exponential time, <em>i.e.</em> the running time for <code>(fib n)</code> is proportional to C<code>*2^n</code> for some constant <span style="font-family: monospace;">C.</span> It is straightforward to write a program that computes <code>(fib n)</code> in time proportional to <code>n</code> as assigned in Problem 4.  Your challenge is to write a program that computes <code>(fib n)</code> in <code><em>log</em> n</code> time assuming that all multiplications and additions take constant time (which is unrealistic for large <code>n)</code>. More precisely, your program should compute <code>(fib n)</code> using only <code>O(</code><code><em>log </em></code><code>n)</code> addition and multiplication operations (less than C<code>*</code><code><em>log </em></code><code>n</code> operations for some constant <span style="font-family: monospace;">C</span>).</p><p>Hints: </p></li></ol><ul><li style="list-style-type: none;background-image: none;"><ul><li><p> Derive a recurrence for <em><code>fib(2*m) </code></em>in terms of <em><code>fib(m)</code></em> and <em><code>fib(m-1)</code></em>. Derive a similar recurrence for <em>fib(2*m+1)</em>.    To produce an algorithm that runs in log operations you need to reduce computing the pair <code>(<em>fib(2*m),fib(2*m-1))</em></code><em> </em>to computing <code>(<em>fib(m),fib(m-1))</em></code> using a bounded number of arithmetic operations and tests. </p></li><li><p>Initially write a program that works when n is a power of 2.  Then refine this prototype to a program that works for all n.  </p></li><li><p>This is a challenging problem.  Make sure that you have thoroughly completed the regular homework problems before attempting it.</p></li><li>In my solution, I used &quot;dotted pairs&quot; to reduce overhead.  The &quot;dotted pair&quot; representation of a pair (a,b) is (cons a b) which is illegal in all of the HTDP dialects when b is not a list,  It is supported in the &quot;Other Languages&quot; called &quot;Pretty Big&quot;.  Of course you can define pairs using <code>(define-struct pair (left right))</code>.  My intuition was that such pairs have more overhead than dotted pairs but I did not perform any benchmark comparisons. If you decide to use a language other than <code>Advanced Student<code>, please put your solution to the challenge problem in a separate file called Chal02.txt and put a comment in your regular solution file HW02.rkt  for problem 5 to that effect.</li></ul></li></ul></li></ul>
        <p>&nbsp;</p>
    </body>
</html>
